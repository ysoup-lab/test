import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as d,f as a,o as l}from"./app-DAsvFgGW.js";const r="/test/assets/deque-1-Bywbl7jl.png",n={};function i(s,e){return l(),d("div",null,e[0]||(e[0]=[a('<h1 id="java-双端队列-deque" tabindex="-1"><a class="header-anchor" href="#java-双端队列-deque"><span>Java 双端队列 Deque</span></a></h1><h2 id="deque-简介" tabindex="-1"><a class="header-anchor" href="#deque-简介"><span>Deque 简介</span></a></h2><p>Deque <strong>双端队列</strong>（deque，全名 double-ended queue）接口位于 java.util 包中，它是 Queue 队列接口的子类型。</p><p>Deque 支持从数据结构的两端添加和删除元素，因此可以用作栈或队列。</p><p>栈支持后进先出（LIFO）操作，队列支持先进先出（FIFO）操作。而双端队列中的元素可以从两端入队、出队，即可以同时在队头和队尾添加和移除元素。</p><img src="'+r+'" alt="图片" style="zoom:67%;"><h2 id="作用" tabindex="-1"><a class="header-anchor" href="#作用"><span>作用</span></a></h2><p>在日常开发中经常会用到队列和栈的数据结构。</p><p>在 Java 中表示队列和栈的有 Queue 和 Stack，而 Java 中的 Stack 具有设计上的缺陷，滥用了继承，继承了 Vector（ Vector 很多方法都用了 synchronized 修饰，线程安全，但效率太低，已被弃用），暴露了 set/get 方法，导致 Stack 可以进行随机位置的访问，与 Stack 的设计理念相冲突。</p><p>而 Deque 双端队列这种数据结构就很灵活了，即可以满足队列的 FIFO 特性，又可以满足栈的 LIFO 特性，<strong>官方也推荐使用 Deque 代替 Stack</strong>。</p><p>Deque 有两个重要的实现类 <strong>ArrayDeque</strong> 和 <strong>LinkedList</strong> ，分别对应 <strong>顺序存储结构</strong> 及 <strong>链式存储结构</strong>。</p><h2 id="arraydeque" tabindex="-1"><a class="header-anchor" href="#arraydeque"><span>ArrayDeque</span></a></h2><ul><li>数组结构：可变数组来实现</li><li>因为双端队列只能在头部和尾部插入或者删除元素，所以时间复杂度为 <code>O(1)</code>，但是在扩容的时候需要批量移动元素，其时间复杂度为 <code>O(n)</code></li><li>扩容的时候，将数组长度扩容为原来的 2 倍，即 <code>n &lt;&lt; 1</code></li><li>数组采用连续的内存地址空间，所以查询的时候，时间复杂度为 <code>O(1)</code></li><li>它是非线程安全的集合</li><li>不支持插入 <em>null</em> 元素</li></ul><h2 id="linkedlist" tabindex="-1"><a class="header-anchor" href="#linkedlist"><span>LinkedList</span></a></h2><ul><li>基于双向链表的结构，所以长度没有限制，因此不存在扩容机制</li><li>由于链表的内存地址是非连续的，所以只能从头部或者尾部查找元素，查询的时间复杂为 <code>O(n)</code>，但是 JDK 对 <code>LinkedList</code> 做了查找优化，当我们查找某个元素时，若 <code>index &lt; (size / 2)</code>，则从 <code>head</code> 往后查找，否则从 <code>tail</code> 开始往前查找 , 但是我们在计算时间复杂度的时候，常数项可以省略，故时间复杂度 <code>O(n)</code></li><li>链表通过指针去访问各个元素，所以对于插入、删除元素只需要更改指针指向即可，时间复杂度为 <code>O(1)</code></li><li>它是非线程安全的集合</li><li>支持插入 <em>null</em> 元素</li></ul><p><strong>ArrayDeque 比 LinkedList 效率高</strong>：</p><ul><li><p>从速度的角度：<code>ArrayDeque</code> 基于数组实现双端队列，而 <code>LinkedList</code> 基于双向链表实现双端队列，数组采用连续的内存地址空间，通过下标索引访问，链表是非连续的内存地址空间，通过指针访问，所以在寻址方面数组的效率高于链表。</p></li><li><p>从内存的角度：虽然 <code>LinkedList</code> 没有扩容的问题，但是插入元素的时候，需要创建一个 <code>Node</code> 对象, 换句话说每次都要执行 <code>new</code> 操作，当执行 <code>new</code> 操作的时候，其过程是非常慢的，会经历两个过程：类加载过程 、对象创建过程。</p></li></ul><h2 id="常用方法" tabindex="-1"><a class="header-anchor" href="#常用方法"><span>常用方法</span></a></h2><table><thead><tr><th style="text-align:center;">方法</th><th>作用</th></tr></thead><tbody><tr><td style="text-align:center;">boolean add(E e)</td><td>往队列尾部加入元素</td></tr><tr><td style="text-align:center;">void addFirst(E e)</td><td>往队列首部加入元素</td></tr><tr><td style="text-align:center;">void addFirst(E e)</td><td>往队列尾部加入元素</td></tr><tr><td style="text-align:center;">boolean offer(E e)</td><td>将指定元素插入该队列的尾部。与 add 的区别是 add 当没有可用空间时会抛异常，而 offer 会返回 false</td></tr><tr><td style="text-align:center;">boolean offerFirst(E e)</td><td>往队列首部加入元素</td></tr><tr><td style="text-align:center;">boolean offerLast(E e)</td><td>往队列尾部加入元素</td></tr><tr><td style="text-align:center;">E peek()</td><td>返回但不删除双端队列的首元素</td></tr><tr><td style="text-align:center;">E peekFirst()</td><td>返回但不删除双端队列的首元素</td></tr><tr><td style="text-align:center;">E peekLast()</td><td>返回但不删除双端队列的尾元素</td></tr><tr><td style="text-align:center;">E poll()</td><td>返回且删除双端队列的首元素</td></tr><tr><td style="text-align:center;">E pollFirst()</td><td>返回且删除双端队列的首元素</td></tr><tr><td style="text-align:center;">E pollLast()</td><td>返回且删除双端队列的尾元素</td></tr><tr><td style="text-align:center;">E pop()</td><td>从由双端队列表示的堆栈中弹出一个元素</td></tr><tr><td style="text-align:center;">void push(E e)</td><td>将一个元素推入由双端队列表示的堆栈中</td></tr><tr><td style="text-align:center;">int size()</td><td>返回队列中的元素个数</td></tr></tbody></table>',19)]))}const u=t(n,[["render",i],["__file","Java 双端队列 Deque.html.vue"]]),p=JSON.parse('{"path":"/Java/main/Java%20%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%20Deque.html","title":"Java 双端队列 Deque","lang":"zh-CN","frontmatter":{"title":"Java 双端队列 Deque","date":"2024-01-13T00:00:00.000Z","tags":["Java","Deque","队列"],"categories":["Java"]},"headers":[{"level":2,"title":"Deque 简介","slug":"deque-简介","link":"#deque-简介","children":[]},{"level":2,"title":"作用","slug":"作用","link":"#作用","children":[]},{"level":2,"title":"ArrayDeque","slug":"arraydeque","link":"#arraydeque","children":[]},{"level":2,"title":"LinkedList","slug":"linkedlist","link":"#linkedlist","children":[]},{"level":2,"title":"常用方法","slug":"常用方法","link":"#常用方法","children":[]}],"git":{"createdTime":1739185487000,"updatedTime":1739185487000,"contributors":[{"name":"yangji","username":"yangji","email":"2020946884@qq.cin","commits":1}]},"readingTime":{"minutes":3.71,"words":1114},"filePathRelative":"Java/main/Java 双端队列 Deque.md","localizedDate":"2024年1月13日","excerpt":"\\n<h2>Deque 简介</h2>\\n<p>Deque <strong>双端队列</strong>（deque，全名 double-ended queue）接口位于 java.util 包中，它是 Queue 队列接口的子类型。</p>\\n<p>Deque 支持从数据结构的两端添加和删除元素，因此可以用作栈或队列。</p>\\n<p>栈支持后进先出（LIFO）操作，队列支持先进先出（FIFO）操作。而双端队列中的元素可以从两端入队、出队，即可以同时在队头和队尾添加和移除元素。</p>\\n\\n<h2>作用</h2>\\n<p>在日常开发中经常会用到队列和栈的数据结构。</p>\\n<p>在 Java 中表示队列和栈的有 Queue 和 Stack，而 Java 中的 Stack 具有设计上的缺陷，滥用了继承，继承了 Vector（ Vector 很多方法都用了 synchronized 修饰，线程安全，但效率太低，已被弃用），暴露了 set/get 方法，导致 Stack 可以进行随机位置的访问，与 Stack 的设计理念相冲突。</p>"}');export{u as comp,p as data};
