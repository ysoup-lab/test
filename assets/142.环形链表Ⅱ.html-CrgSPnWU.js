import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,f as n,o as l}from"./app-Vzr6EyvM.js";const e="/test/assets/image-20230829135004365-c7UkAfZp.png",t={};function h(p,s){return l(),a("div",null,s[0]||(s[0]=[n(`<h1 id="_142-环形链表ii" tabindex="-1"><a class="header-anchor" href="#_142-环形链表ii"><span>142.环形链表Ⅱ</span></a></h1><p><strong>难度：中等</strong></p><p>给定一个链表的头节点 <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><p><strong>示例 1：</strong></p><figure><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入：head = [3,2,0,-4], pos = 1</span></span>
<span class="line"><span>输出：返回索引为 1 的链表节点</span></span>
<span class="line"><span>解释：链表中有一个环，其尾部连接到第二个节点。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><figure><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入：head = [1,2], pos = 0</span></span>
<span class="line"><span>输出：返回索引为 0 的链表节点</span></span>
<span class="line"><span>解释：链表中有一个环，其尾部连接到第一个节点。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3：</strong></p><figure><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入：head = [1], pos = -1</span></span>
<span class="line"><span>输出：返回 null</span></span>
<span class="line"><span>解释：链表中没有环。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><p>**进阶：**你是否可以使用 <code>O(1)</code> 空间解决此题？</p><h2 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路"><span>解题思路</span></a></h2><p>联想 <strong>160. 相交链表</strong> 的哈希做法，显然这个题可以采用的暴力做法是：<strong>哈希集合 HashSet</strong></p><p>我的思路：</p><ol><li>设定一个哈希集合 hashSet 用来存储链表 head 里面的节点</li><li>遍历链表 head，对于遍历到的每个节点，判断该节点是否在哈希集合中，并将链表 head 中的每个节点加入哈希集合中 <ul><li>如果当前节点不在哈希集合中，则继续遍历链表 head</li><li>如果当前节点在哈希集合中，则说明目标节点已经找到，链表存在环，返回该节点</li></ul></li><li>若链表 head 遍历结束仍没有找到目标节点，说明链表无环，返回 null</li></ol><h2 id="我的代码-哈希集合" tabindex="-1"><a class="header-anchor" href="#我的代码-哈希集合"><span>我的代码（哈希集合）</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ListNode</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> detectCycle</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ListNode</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> head) {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    HashSet</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ListNode</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> set </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> HashSet</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    ListNode</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> cur</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    //用head初始化hashSet</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (cur </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> head</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> !</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">contains</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(cur)</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> cur </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> cur </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> cur</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(cur);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    //链表无环</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> cur</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><h3 id="hashset" tabindex="-1"><a class="header-anchor" href="#hashset"><span>HashSet</span></a></h3><p>结构特点：</p><ul><li>HashSet 是一个<strong>没有重复元素的集合</strong>。它的底层结构是依靠 HashMap 来实现的。实现方式大致为：通过一个 HashMap 存储元素，元素是存放在 HashMap 的 Key 中，而 Value 统一使用一个 Object 对象。</li><li>HashSet <strong>不保证元素的顺序</strong>，而且 HashSet 允许使用 null 元素。</li><li>HashSet 是 <strong>非同步的</strong>，如果多个线程同时访问一个 HashSet ，而其中至少一个线程修改了该 HashSet ，那么它必须保持外部同步。</li><li>HashSet 按 Hash 算法来存储集合的元素，因此具有很好的存取和查找性能。</li></ul><p>使用和理解中需要注意的细节：</p><ul><li><p>HashSet 中是允许存入null值的，但是在 HashSet 中仅仅能够存入一个null值。</p></li><li><p><strong>HashSet 中存储元素的位置是固定的</strong> HashSet 中存储的元素的是无序的，由于 HashSet 底层是基于 Hash 算法实现的，使用了 hashcode，所以 HashSet 中相应的元素的位置是固定的</p></li><li><p><strong>必须小心操作可变对象</strong>（<code>Mutable Object</code>） 如果一个 HashSet 中的可变元素改变了自身状态使得 <code>Object.equals(Object)=true</code>，那么将导致一些问题。</p></li></ul><h2 id="双指针法" tabindex="-1"><a class="header-anchor" href="#双指针法"><span>双指针法</span></a></h2><h3 id="思路解析" tabindex="-1"><a class="header-anchor" href="#思路解析"><span>思路解析</span></a></h3><p>这道题可以使用 <strong>快慢指针法</strong>，分别定义 fast 和 slow 指针，同时从链表头结点出发，fast 指针每次移动两个节点，slow 指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，则说明这个链表有环。</p><p>问题是，在 fast 一步走两个节点，slow 一步走一个节点的情况下，如果链表有环，这两个指针一定会在环内相遇吗？会不会巧合般的永远错开呢？</p><p>答案是：<strong>fast 指针会先进入环中，并且 fast 指针和 slow 指针一定会在环中相遇。</strong></p><p>证明过程：</p><ol><li>显然 fast 指针先进入环中，我们假设环中一共有 e 个节点</li><li>当 slow 指针首次进入环中，来到环中第 1 个节点时，假设 fast 指针处在环中第 w + 1 个节点的位置，那么二者此时的正向距离为 w，显然 0 &lt;= w &lt; e</li><li>由于 slow 指针一步走一个节点，fast 指针一步走两个节点，那么二者的正向距离从 w 开始，每走 t 步，其正向距离为：(w + 2 * t - t) % e = (w + t) % e</li><li>显然，当 t 从 0 逐步增加到 e - w 的时候，两个指针的距离刚好为 0，此时二者相遇，并且根据上式可知 0 &lt;= t &lt; e - w &lt; e，也就是说，<strong>此次相遇的时候， slow 指针在环中还未走完一圈</strong></li></ol><p>综上，我们证明了可以通过快慢指针法在链表中找到环。</p><p>那么第二个问题是，<strong>在找到环之后，如何找到环的入口</strong>？</p><p>假设从链表头结点到环入口的节点数为 x， 环入口到 fast 指针与 slow 指针首次相遇节点的距离为 y，从相遇节点再到环入口的距离为 z。 如图所示：</p><img src="`+e+`" alt="image-20230829135004365" style="zoom:67%;"><p>显然， fast 指针与 slow 指针首次相遇时： slow 走了 x + y 步，fast 走了 x + y + n (y + z) 步。</p><p>其中 n 的含义是： fast 指针在环内比 slow 多走了 n 圈才遇到 slow 指针，y + z 为环的长度。</p><p>因为 fast 指针一步走两个节点，slow 指针一步走一个节点， 所以 fast 指针的位移 = 2 * slow 指针的位移，即：(x + y) * 2 = x + y + n (y + z)，化简得 x + y = n (y + z)</p><p><strong>如果我们能求得 x，再令一个指针从链表头指针移动 x 步，就可以找到想找环形的入口。</strong></p><p>所以将 x 单独放在等式左边：x = n (y + z) - y，再从 n ( y + z ) 中提出一个 ( y + z ) 来，整理公式之后为如下公式：x = (n - 1) (y + z) + z</p><p><strong>注意：上式的 n 一定是大于等于 1 的，因为 fast 指针至少要多走一圈才能相遇 slow 指针。</strong></p><p>由于 [(n - 1) (y + z) + z] % (y + z) = z，则 x % (y + z) = z，这就意味着，<strong>倘若从头结点出发一个指针 temp，从相遇节点也出发一个指针 slow，这两个指针每步只走一个节点， 那么当 temp 走了 x 步的时候，temp 到达了环入口，slow 也刚好到达了环入口，此时二者刚好是第一次相遇。</strong></p><h3 id="代码展示" tabindex="-1"><a class="header-anchor" href="#代码展示"><span>代码展示</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ListNode</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> detectCycle</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ListNode</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> head) {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    ListNode</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> fast </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> head</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    ListNode</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> slow </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> head</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">	// 使用快慢指针检测环</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    while</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (fast </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> fast</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> !=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        slow </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> slow</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        fast </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> fast</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 快慢指针相遇，表示链表有环</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (fast </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> slow) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 从头节点和相遇点同时开始遍历，再次相遇点即为环的起始点</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">            ListNode</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> temp </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> head</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            while</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (temp </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> slow) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">                temp </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> temp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">                slow </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> slow</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> temp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    //链表无环</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>时间复杂度：O(n)，快慢指针相遇前，指针走的次数小于链表长度，快慢指针相遇后，两个指针走的次数也小于链表长度，总体为走的次数小于 2 * n</p><p>空间复杂度：O(1)</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>这道题目，不仅考察对链表的操作，而且还需要一些数学运算。</p><p>主要考察两知识点：</p><ul><li>判断链表是否环</li><li>如果有环，如何找到这个环的入口</li></ul>`,56)]))}const r=i(t,[["render",h],["__file","142.环形链表Ⅱ.html.vue"]]),g=JSON.parse('{"path":"/LeetCode/main/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E2%85%A1.html","title":"142.环形链表Ⅱ","lang":"zh-CN","frontmatter":{"title":"142.环形链表Ⅱ","date":"2023-08-26T00:00:00.000Z","tags":["哈希表","链表","双指针"],"categories":["力扣每日一题"]},"headers":[{"level":2,"title":"解题思路","slug":"解题思路","link":"#解题思路","children":[]},{"level":2,"title":"我的代码（哈希集合）","slug":"我的代码-哈希集合","link":"#我的代码-哈希集合","children":[{"level":3,"title":"HashSet","slug":"hashset","link":"#hashset","children":[]}]},{"level":2,"title":"双指针法","slug":"双指针法","link":"#双指针法","children":[{"level":3,"title":"思路解析","slug":"思路解析","link":"#思路解析","children":[]},{"level":3,"title":"代码展示","slug":"代码展示","link":"#代码展示","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1739185487000,"updatedTime":1739185487000,"contributors":[{"name":"yangji","username":"yangji","email":"2020946884@qq.cin","commits":1}]},"readingTime":{"minutes":6.55,"words":1964},"filePathRelative":"LeetCode/main/142.环形链表Ⅱ.md","localizedDate":"2023年8月26日","excerpt":"\\n<p><strong>难度：中等</strong></p>\\n<p>给定一个链表的头节点 <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p>\\n<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>"}');export{r as comp,g as data};
